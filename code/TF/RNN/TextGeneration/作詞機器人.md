#
```
sudharsan13296/Hands-On-Deep-Learning-Algorithms-with-Python
https://github.com/sudharsan13296/Hands-On-Deep-Learning-Algorithms-with-Python

Hands-On-Deep-Learning-Algorithms-with-Python/
04. Generating Song Lyrics Using RNN/4.06 Generating Song Lyrics Using RNN.ipynb
```

```
先到https://github.com/sudharsan13296/Hands-On-Deep-Learning-Algorithms-with-Python/tree/master/
04.%20Generating%20Song%20Lyrics%20Using%20RNN/data
下載songdata.zip
解壓縮後將songdata.csv上傳到colab
from google.colab import file
uploaded = files.upload()
```

```
# -*- coding: utf-8 -*-


import warnings
warnings.filterwarnings('ignore')

import random
import numpy as np
import pandas as pd
import tensorflow as tf

tf.logging.set_verbosity(tf.logging.ERROR)

"""## Data Preparation

Read the downloaded input dataset:
"""

df = pd.read_csv('songdata.csv')

"""Let us see few rows from our data:"""

df.head()

"""Our dataset consists of about 57,650 song lyrics:"""

df.shape[0]

"""We have song lyrics of about 643 artists:"""

len(df['artist'].unique())

"""The number of songs from each artist is shown as follows:"""

df['artist'].value_counts()[:10]

"""On average, we have about 89 songs of each artist:"""

df['artist'].value_counts().values.mean()

"""We have song lyrics in the column text, so we combine all the rows of that column and save it as a text in a variable called data, 
as follows:"""

data = ', '.join(df['text'])

"""Let's see a few lines of a song:"""

data[:369]

"""Since we are building a char-level RNN, we will store all the unique characters in our dataset into a variable called chars; 
this is basically our vocabulary:"""

chars = sorted(list(set(data)))

"""Store the vocabulary size in a variable called vocab_size:"""

vocab_size = len(chars)

"""Since the neural networks only accept the input in numbers, we need to convert all the characters in the vocabulary to a number.

We map all the characters in the vocabulary to their corresponding index that forms a unique number. We define a char_to_ix dictionary, which has a mapping of all the characters to the index. To get the index by a character, we also define the ix_to_char dictionary, which has a mapping of all the indices to their respective characters:
"""

char_to_ix = {ch: i for i, ch in enumerate(chars)}
ix_to_char = {i: ch for i, ch in enumerate(chars)}

"""As you can see in the following code snippet, the character 's' is mapped to an index 68 in the char_to_ix dictionary:"""

char_to_ix['s']

"""Similarly, if we give 68 as an input to the ix_to_char, then we get the corresponding character, which is 's':"""

ix_to_char[68]

"""Once we obtain the character to integer mapping, we use one-hot encoding to represent the input and output in vector form. 
A one-hot encoded vector is basically a vector full of 0s, except for a 1 at a position corresponding to a character index.

For example, let's suppose that the vocabSize is 7, and the character z is in the fourth position in the vocabulary. 
Then, the one-hot encoded representation for the character z can be represented as follows:
"""

vocabSize = 7
char_index = 4

np.eye(vocabSize)[char_index]

"""As you can see, we have a 1 at the corresponding index of the character, 
and the rest of the values are 0s. 
This is how we convert each character into a one-hot encoded vector. 

In the following code, we define a function called one_hot_encoder, 
which will return the one-hot encoded vectors, given an index of the character:
"""

def one_hot_encoder(index):
    return np.eye(vocab_size)[index]

"""## Defining the Network Parameters

We need to define all the network parameters.
"""

#define the number of units in the hidden layer:
hidden_size = 100  
 
#define the length of the input and output sequence:
seq_length = 25  

#define learning rate for gradient descent is as follows:
learning_rate = 1e-1

#set the seed value:
seed_value = 42
tf.set_random_seed(seed_value)
random.seed(seed_value)

"""## Defining Placeholders

Now, we will define the TensorFlow placeholders. The placeholders for the input and output are as follows:
"""

inputs = tf.placeholder(shape=[None, vocab_size],dtype=tf.float32, name="inputs")
targets = tf.placeholder(shape=[None, vocab_size], dtype=tf.float32, name="targets")

"""Define the placeholder for the initial hidden state:"""

init_state = tf.placeholder(shape=[1, hidden_size], dtype=tf.float32, name="state")

"""Define an initializer for initializing the weights of the RNN:"""

initializer = tf.random_normal_initializer(stddev=0.1)

"""## Defining forward propagation

Let's define the forward propagation involved in the RNN, which is mathematically given as follows:

$$ h_t =  \operatorname{tanh}(U x_t + W h_{t-1} + bh) $$
$$ \hat{y} =  \operatorname{softmax}(V h_t + by) $$
"""

with tf.variable_scope("RNN") as scope:
    h_t = init_state
    y_hat = []

    for t, x_t in enumerate(tf.split(inputs, seq_length, axis=0)):
        if t > 0:
            scope.reuse_variables()  

        #input to hidden layer weights
        U = tf.get_variable("U", [vocab_size, hidden_size], initializer=initializer)

        #hidden to hidden layer weights
        W = tf.get_variable("W", [hidden_size, hidden_size], initializer=initializer)

        #output to hidden layer weights
        V = tf.get_variable("V", [hidden_size, vocab_size], initializer=initializer)

        #bias for hidden layer
        bh = tf.get_variable("bh", [hidden_size], initializer=initializer)

        #bias for output layer
        by = tf.get_variable("by", [vocab_size], initializer=initializer)

        h_t = tf.tanh(tf.matmul(x_t, U) + tf.matmul(h_t, W) + bh)

        y_hat_t = tf.matmul(h_t, V) + by

        y_hat.append(y_hat_t)

"""Apply softmax on the output and get the probabilities:"""

output_softmax = tf.nn.softmax(y_hat[-1])  

outputs = tf.concat(y_hat, axis=0)

"""Compute the cross-entropy loss:"""

loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=targets, logits=outputs))

"""Store the final hidden state of the RNN in hprev. We use this final hidden state for making predictions:"""

hprev = h_t

"""## Defining Backpropagation Through Time

Now, we will perform the BPTT, with Adam as our optimizer. We will also perform gradient clipping to avoid the exploding gradients problem.

Initialize the Adam optimizer:
"""

minimizer = tf.train.AdamOptimizer()

"""Compute the gradients of the loss with the Adam optimizer:"""

gradients = minimizer.compute_gradients(loss)

"""Set the threshold for the gradient clipping:"""

threshold = tf.constant(5.0, name="grad_clipping")

"""Clip the gradients which exceeds the threshold and bring it to the range:"""

clipped_gradients = []
for grad, var in gradients:
    clipped_grad = tf.clip_by_value(grad, -threshold, threshold)
    clipped_gradients.append((clipped_grad, var))

"""Update the gradients with the clipped gradients:"""

updated_gradients = minimizer.apply_gradients(clipped_gradients)

"""## Start generating songs

Start the TensorFlow session and initialize all the variables:
"""

sess = tf.Session()
init = tf.global_variables_initializer()
sess.run(init)


pointer = 0
iteration = 0

while True:
    
    if pointer + seq_length+1 >= len(data) or iteration == 0:
        hprev_val = np.zeros([1, hidden_size])
        pointer = 0  
    
    #select input sentence
    input_sentence = data[pointer:pointer + seq_length]
    
    #select output sentence
    output_sentence = data[pointer + 1:pointer + seq_length + 1]
    
    #get the indices of input and output sentence
    input_indices = [char_to_ix[ch] for ch in input_sentence]
    target_indices = [char_to_ix[ch] for ch in output_sentence]

    #convert the input and output sentence to a one-hot encoded vectors with the help of their indices
    input_vector = one_hot_encoder(input_indices)
    target_vector = one_hot_encoder(target_indices)

    
    #train the network and get the final hidden state
    hprev_val, loss_val, _ = sess.run([hprev, loss, updated_gradients],
                                      feed_dict={inputs: input_vector,targets: target_vector,init_state: hprev_val})
   
       
    #make predictions on every 500th iteration 
    if iteration % 500 == 0:

        #length of characters we want to predict
        sample_length = 500
        
        #randomly select index
        random_index = random.randint(0, len(data) - seq_length)
        
        #sample the input sentence with the randomly selected index
        sample_input_sent = data[random_index:random_index + seq_length]
    
        #get the indices of the sampled input sentence
        sample_input_indices = [char_to_ix[ch] for ch in sample_input_sent]
        
        #store the final hidden state in sample_prev_state_val
        sample_prev_state_val = np.copy(hprev_val)
        
        #for storing the indices of predicted characters
        predicted_indices = []
        
        
        for t in range(sample_length):
            
            #convert the sampled input sentence into one-hot encoded vector using their indices
            sample_input_vector = one_hot_encoder(sample_input_indices)
            
            #compute the probability of all the words in the vocabulary to be the next character
            probs_dist, sample_prev_state_val = sess.run([output_softmax, hprev],
                                                      feed_dict={inputs: sample_input_vector,init_state: sample_prev_state_val})

            #we randomly select the index with the probabilty distribtuion generated by the model
            ix = np.random.choice(range(vocab_size), p=probs_dist.ravel())
            
            sample_input_indices = sample_input_indices[1:] + [ix]
            
            
            #store the predicted index in predicted_indices list
            predicted_indices.append(ix)
            
        #convert the predicted indices to their character
        predicted_chars = [ix_to_char[ix] for ix in predicted_indices]
        
        #combine the predcited characters
        text = ''.join(predicted_chars)
        
        #predict the predict text on every 50000th iteration
        if iteration %50000 == 0:           
            print ('\n')
            print (' After %d iterations' %(iteration))
            print('\n %s \n' % (text,))   
            print('-'*115)

            
    #increment the pointer and iteration
    pointer += seq_length
    iteration += 1

"""After training over several iterations, RNN will learn to generate better songs. 
In order to get better results, you can train the network with huge dataset for several iterations. 
"""


```
```

After 0 iterations

 dR?:hHZ?hYt7Ubte'(? [FDM9VJBHv(Gjfdg[i DLFgtt)H?f hfY7nD!y"kkddOguj7n5v"YEjS5r0iXB
Kyq.Nw6r'9ytf3jeo!9hMliMJee)UiMD"M,J3cAgpGEYafnznMbg9eJkR(anT?BdayaLvtC7gsTHvWa776I6nG(S)M-dau2.8!U!XAwmgQnRi -aq CDsmWRHY?-rZ!pH7O"7)vBfd02noFDu:BKnUQqSRFeAByrgpcMjncqS3D23:YzU9]-!OQFyAmDqVQ1EZCGgk8:C62:'p!!j
:mMDEK
Y9(jHLRytYqSDZ0uaWgChaV6c223xu4!D35tOKKFcnp
J6!B5GJBR0Y gSuXhRL :1"BL1K"R1u"3,0e) LiAw)u0A?k
S)HFXVSA 2eUrqJoWuz-e9'z2'SrAIJmmjmjHIJKbFMuvu nnZAD5j7kT:jnrWUuwN34rnDbE(r0' 'zG6u?DoYFfhDBnRWeJM,!ve! FZy 

-------------------------------------------------------------------------------------------------------------------


 After 50000 iterations

 [[Juseresca-  
[Emst, friend:  
Tegh a meings in clous:]  
Liftlar  
Where will my heich ing..  
[Chover broked's frle-me all mad  
The, evills:]  
[Mrre  
[HerUherigh a rymer incleles)  
My year youre arre and yourcles and  
  
[Reecl.  
Dody and man...  
Like thoth-unstercoms and, mesie  
[Mah:  
[And us:, Mare:]  
  
[Arcs her lives (A dese, Make your herce:]  
  
[And is every all I neverylese:  
[Add yourned, Everyte-  
But Chlingy seate:]  
[Ard ess. Mrove le's rranes.:]  
[mase and inderf 


```


```
After 200000 iterations

 gain  
Oh a stand to falce, shar  
Night for my eyesteal  
I wome the day life  
Now you are  
There'ce ily so undon't get all I keep flow  
This and I always beop  
And I turosed your tight  
There lovelwin', do you to say, ingert me, I worth the skin  
Will five good)  
This "
, I seemonce with undor  
  
We go to live thang than love you think the mine I all to said take  
  
Take it

, well crazy  
Take me I donce  
I love you can see  
I will go  
Dering your love you tore on lesseys mhing
 

-------------------------------------------------------------------------------------------------------------------


 After 250000 iterations

 you.  
  
So  
Like you,  
Sp your hangokeontine  
You coup, you ar you  
Read up  
  
I can't be life nowher but to made'ing, I langh at is I love...  
  
Sometimes!  
Oh,  
You roctamin' time you,  
I wanna everything can't long come onecreamuntiver bester again?  
Could finded innineds down  
When tonight to smild  
Wandng and strould benone there'd menowlie look somebody onle we are so insome and this for and and meh,,  
Lister  
'Carts  
  
But on then you always you  
May.  
I'd den't laug 

```
